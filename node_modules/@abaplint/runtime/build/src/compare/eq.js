"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eq = void 0;
const types_1 = require("../types");
function compareTables(left, right) {
    const leftArray = left.array();
    const rightArray = right.array();
    if (leftArray.length !== rightArray.length) {
        return false;
    }
    for (let i = 0; i < leftArray.length; i++) {
        const rowCompare = eq(leftArray[i], rightArray[i]);
        if (rowCompare === false) {
            return false;
        }
    }
    return true;
}
function eq(left, right) {
    /*
      console.dir(left);
      console.dir(right);
    */
    if (right instanceof types_1.FieldSymbol) {
        return eq(left, right.getPointer());
    }
    else if (left instanceof types_1.FieldSymbol) {
        return eq(left.getPointer(), right);
    }
    if (left instanceof types_1.Table || right instanceof types_1.Table) {
        if (left instanceof types_1.Table && right instanceof types_1.Table) {
            return compareTables(left, right);
        }
        else {
            // this happens in dynamic/ANY typed scenarios?
            return false;
        }
    }
    if (left instanceof types_1.Structure || right instanceof types_1.Structure) {
        if (!(right instanceof types_1.Structure)) {
            return false;
        }
        if (!(left instanceof types_1.Structure)) {
            return false;
        }
        const l = left.get();
        const r = right.get();
        const leftKeys = Object.keys(l);
        const rightKeys = Object.keys(r);
        if (leftKeys.length !== rightKeys.length) {
            return false;
        }
        for (const k of leftKeys) {
            const e = eq(l[k], r[k]);
            if (e === false) {
                return false;
            }
        }
        return true;
    }
    let l = undefined;
    if (left instanceof types_1.Character) {
        l = left.getTrimEnd();
    }
    else if (typeof left === "object") {
        l = left.get();
    }
    else {
        l = left;
    }
    let r = undefined;
    if (right instanceof types_1.Character) {
        r = right.getTrimEnd();
    }
    else if (typeof right === "object") {
        r = right.get();
    }
    else {
        r = right;
    }
    if (right instanceof types_1.Hex && typeof l === "number") {
        r = parseInt(right.get(), 16);
    }
    else if (left instanceof types_1.Hex && typeof r === "number") {
        l = parseInt(left.get(), 16);
    }
    if (right instanceof types_1.Float && left instanceof types_1.Float) {
        r = right.getRaw();
        l = left.getRaw();
    }
    else if (right instanceof types_1.Float && typeof l === "number") {
        r = right.getRaw();
    }
    else if (left instanceof types_1.Float) {
        if (typeof r === "number") {
            l = left.getRaw();
        }
        else if (typeof r === "string") {
            l = left.getRaw();
            r = Number(r);
        }
    }
    if (right instanceof types_1.Numc && left instanceof types_1.Integer) {
        l = left.get();
        r = parseInt(right.get(), 10);
    }
    else if (right instanceof types_1.Integer && left instanceof types_1.Numc) {
        r = right.get();
        l = parseInt(left.get(), 10);
    }
    // assumption: typically no casts are required, so start checking if the types doesnt match
    if (typeof l !== typeof r) {
        if (typeof l === "string" && typeof r === "number") {
            r = r.toString();
        }
        else if (typeof l === "number" && typeof r === "string") {
            if (r === "") {
                r = 0;
            }
            else {
                r = parseInt(r, 10);
            }
        }
    }
    /*
      console.dir(l);
      console.dir(r);
    */
    return l === r;
}
exports.eq = eq;
//# sourceMappingURL=eq.js.map