"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.find = void 0;
const types_1 = require("../types");
function find(input, options) {
    var _a, _b, _c, _d, _e, _f, _g;
    let sectionOffset = (_a = options.sectionOffset) === null || _a === void 0 ? void 0 : _a.get();
    if (sectionOffset && options.byteMode) {
        sectionOffset = sectionOffset * 2;
    }
    let s = "";
    if (options.find) {
        s = options.find;
        if (typeof s !== "string") {
            s = s.get();
        }
        if (s === "") {
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
            return;
        }
        s = s.replace(/\[/g, "\\[");
        s = s.replace(/\]/g, "\\]");
        s = s.replace(/\?/g, "\\?");
        s = s.replace(/\(/g, "\\(");
        s = s.replace(/\)/g, "\\)");
        s = s.replace(/\./g, "\\.");
        s = s.replace(/\|/g, "\\|");
        s = s.replace(/\*/g, "\\*");
        s = s.replace(/\+/g, "\\+");
        s = new RegExp(s, "g");
    }
    else if (options.regex) {
        if (options.regex === "") {
            throw "FIND, runtime, no input, regex empty";
        }
        let r = options.regex;
        if (typeof r !== "string") {
            r = r.get();
        }
        // check type, it can also be a CL_ABAP_REGEX
        if (typeof r === "string") {
            r = r.replace("[[:space:]]", "\\s");
        }
        s = new RegExp(r, "g" + (options.ignoringCase === true ? "i" : ""));
    }
    else {
        throw "FIND, runtime, no input";
    }
    const matches = [];
    if (input instanceof types_1.Table) {
        let line = 1;
        for (const blah of input.array()) {
            let temp;
            // eslint-disable-next-line no-cond-assign
            while (temp = s.exec(blah.get())) {
                matches.push(Object.assign(Object.assign({}, temp), { line }));
                if (options.first === true) {
                    break;
                }
            }
            line++;
        }
    }
    else {
        let blah = input.get();
        if (sectionOffset) {
            blah = blah.substr(sectionOffset);
        }
        let temp;
        // eslint-disable-next-line no-cond-assign
        while (temp = s.exec(blah)) {
            matches.push(temp);
            if (options.first === true) {
                break;
            }
        }
    }
    if (options.submatches) {
        for (let index = 0; index < options.submatches.length; index++) {
            if (matches[0] && matches[0][index + 1]) {
                options.submatches[index].set(matches[0][index + 1]);
            }
            else if (matches.length > 0) {
                options.submatches[index].clear();
            }
        }
    }
    if (options.results) {
        // assumption, results is a table with the correct type
        options.results.clear();
        for (const m of matches) {
            const match = new types_1.Structure({
                line: new types_1.Integer(),
                offset: new types_1.Integer(),
                length: new types_1.Integer(),
                submatches: new types_1.Table(new types_1.Structure({ offset: new types_1.Integer(), length: new types_1.Integer() })),
            });
            match.get().line.set(m.line || 0);
            match.get().offset.set(m.index);
            match.get().length.set(m[0].length);
            const submatch = new types_1.Structure({ offset: new types_1.Integer(), length: new types_1.Integer() });
            for (let i = 1; i < m.length; i++) {
                if (m[i] === undefined) {
                    submatch.get().offset.set(-1);
                    submatch.get().length.set(0);
                }
                else {
                    submatch.get().offset.set(m.index + m[0].indexOf(m[i]));
                    submatch.get().length.set(m[i].length);
                }
                match.get().submatches.append(submatch);
            }
            if (options.results instanceof types_1.Table) {
                options.results.append(match);
            }
            else {
                options.results.set(match);
            }
            if (options.first === undefined || options.first === true) {
                break;
            }
        }
    }
    if (matches.length === 0) {
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(4);
    }
    else {
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(0);
    }
    if (((_b = matches[0]) === null || _b === void 0 ? void 0 : _b.index) !== undefined) {
        let val = matches[0].index;
        if (sectionOffset) {
            val += sectionOffset;
        }
        if (options.byteMode) {
            val = val / 2;
        }
        (_c = options.offset) === null || _c === void 0 ? void 0 : _c.set(val);
    }
    if (options === null || options === void 0 ? void 0 : options.count) {
        (_d = options.count) === null || _d === void 0 ? void 0 : _d.set(matches.length);
    }
    else {
        (_e = options.count) === null || _e === void 0 ? void 0 : _e.clear();
    }
    if ((options === null || options === void 0 ? void 0 : options.length) && matches && matches[0]) {
        (_f = options.length) === null || _f === void 0 ? void 0 : _f.set(matches[0][0].length);
    }
    else {
        (_g = options.length) === null || _g === void 0 ? void 0 : _g.clear();
    }
}
exports.find = find;
//# sourceMappingURL=find.js.map