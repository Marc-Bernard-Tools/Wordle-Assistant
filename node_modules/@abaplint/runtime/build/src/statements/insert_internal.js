"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertInternal = void 0;
const clone_1 = require("../clone");
const compare_1 = require("../compare");
const types_1 = require("../types");
const read_table_1 = require("./read_table");
const sort_1 = require("./sort");
function insertInternal(options) {
    var _a;
    if (options.table instanceof types_1.FieldSymbol) {
        options.table = options.table.getPointer();
    }
    const tableOptions = options.table.getOptions();
    const isSorted = (tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.type) === types_1.TableAccessType.sorted || (tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.type) === types_1.TableAccessType.hashed;
    if (isSorted) {
        const insert = options.data instanceof types_1.Structure ? options.data.get() : { table_line: options.data };
        const compare = (row) => {
            for (const key of (tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.keyFields) || []) {
                if ((0, compare_1.ne)(row[key.toLowerCase()], insert[key.toLowerCase()])) {
                    return false;
                }
            }
            return true;
        };
        if (tableOptions.isUnique === true) {
            (0, read_table_1.readTable)(options.table, { withKey: compare });
            // @ts-ignore
            if (abap.builtin.sy.get().subrc.get() === 0) {
                // @ts-ignore
                abap.builtin.sy.get().subrc.set(4);
                return;
            }
        }
    }
    let data = options.data;
    if (typeof data === "string") {
        const tmp = (0, clone_1.clone)(options.table.getRowType());
        tmp.set(data);
        data = tmp;
    }
    if (data && options.index) {
        const index = options.index.get() - 1;
        const val = options.table.insertIndex(data, index);
        if (options.assigning) {
            options.assigning.assign(val);
        }
    }
    else if (options.lines && options.data instanceof types_1.Table) {
        for (const i of options.data.array()) {
            options.table.append(i);
        }
    }
    else if (options.initial === true) {
        let index = options.table.array().length;
        if (options.index) {
            index = options.index.get() - 1;
        }
        const val = options.table.insertIndex(options.table.getRowType(), index);
        if (options.assigning) {
            options.assigning.assign(val);
        }
    }
    else if (data) {
        // todo, for now it just appends, this is not correct, but currently the table type is not known
        const val = options.table.insertIndex(data, options.table.array().length);
        if (options.assigning) {
            options.assigning.assign(val);
        }
        if (options.referenceInto) {
            options.referenceInto.assign(val);
        }
    }
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(0);
    if (isSorted) {
        // slow, but works for now
        const by = (_a = tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.keyFields) === null || _a === void 0 ? void 0 : _a.map(f => { return { component: f.toLowerCase() }; });
        (0, sort_1.sort)(options.table, { by: by });
    }
}
exports.insertInternal = insertInternal;
//# sourceMappingURL=insert_internal.js.map