"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readTable = void 0;
const compare_1 = require("../compare");
const types_1 = require("../types");
function readTable(table, options) {
    var _a;
    let found = undefined;
    let foundIndex = 0;
    const arr = table.array();
    if (options === null || options === void 0 ? void 0 : options.index) {
        let index = options.index;
        if (typeof index !== "number") {
            index = index.get();
        }
        found = arr[index - 1];
        if (found) {
            foundIndex = index;
        }
    }
    else if (options === null || options === void 0 ? void 0 : options.withKey) {
        const isStructured = arr[0] instanceof types_1.Structure;
        for (const a of arr) {
            foundIndex++;
            const row = isStructured ? Object.assign({ table_line: a }, a.get()) : { table_line: a };
            if (options.withKey(row) === true) {
                found = a;
                break;
            }
        }
        if (found === undefined) {
            foundIndex = 0;
        }
    }
    else if (options === null || options === void 0 ? void 0 : options.from) {
        if (table instanceof types_1.Table && options.from instanceof types_1.Structure) {
            const keys = (_a = table.getOptions()) === null || _a === void 0 ? void 0 : _a.keyFields;
            const isStructured = arr[0] instanceof types_1.Structure;
            if (keys !== undefined && isStructured === true) {
                //        console.dir(keys);
                //        console.dir(options.from.get()[keys[0].toLowerCase()]);
                for (const a of arr) {
                    foundIndex++;
                    let matches = true;
                    for (const k of keys) {
                        if ((0, compare_1.eq)(a.get()[k.toLowerCase()], options.from.get()[k.toLowerCase()]) === false) {
                            matches = false;
                            break;
                        }
                    }
                    if (matches === true) {
                        found = arr;
                        break;
                    }
                }
            }
        }
        if (found === undefined) {
            foundIndex = 0;
        }
    }
    else {
        throw new Error("runtime, readTable, unexpected input");
    }
    let subrc = found ? 0 : 4;
    if ((options === null || options === void 0 ? void 0 : options.from) && subrc === 4) {
        subrc = 8;
    }
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(subrc);
    // @ts-ignore
    abap.builtin.sy.get().tabix.set(foundIndex);
    if (options.into && found) {
        if (options.into instanceof types_1.DataReference && found instanceof types_1.DataReference) {
            options.into.assign(found.getPointer());
        }
        else if (options.into instanceof types_1.DataReference) {
            options.into.assign(found);
        }
        else {
            options.into.set(found);
        }
    }
    else if (options.referenceInto && found) {
        options.referenceInto.assign(found);
    }
    else if (options.assigning && found) {
        options.assigning.assign(found);
    }
    return { subrc, foundIndex };
}
exports.readTable = readTable;
//# sourceMappingURL=read_table.js.map