"use strict";
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteInternal = void 0;
const types_1 = require("../types");
const compare_1 = require("../compare");
const loop_1 = require("./loop");
async function deleteInternal(target, options) {
    var e_1, _a;
    let prev = undefined;
    let index = 0;
    if (target instanceof types_1.FieldSymbol) {
        target = target.getPointer();
        if (target === undefined) {
            throw "FS not assigned";
        }
    }
    if ((options === null || options === void 0 ? void 0 : options.index)
        && (options === null || options === void 0 ? void 0 : options.where) === undefined
        && (options === null || options === void 0 ? void 0 : options.adjacent) === undefined
        && (options === null || options === void 0 ? void 0 : options.fromValue) === undefined
        && (options === null || options === void 0 ? void 0 : options.from) === undefined
        && (options === null || options === void 0 ? void 0 : options.to) === undefined) {
        if (target.array()[options.index.get() - 1] === undefined) {
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(4);
            return;
        }
        else {
            target.deleteIndex(options.index.get() - 1);
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
            return;
        }
    }
    try {
        for (var _b = __asyncValues((0, loop_1.loop)(target)), _c; _c = await _b.next(), !_c.done;) {
            const i = _c.value;
            // @ts-ignore
            index = abap.builtin.sy.get().tabix.get() - 1;
            if (options === null || options === void 0 ? void 0 : options.where) {
                const row = i instanceof types_1.Structure ? i.get() : { table_line: i };
                if (options.where(row) === true) {
                    target.deleteIndex(index);
                }
            }
            else if ((options === null || options === void 0 ? void 0 : options.adjacent) === true && prev !== undefined) {
                if (options === null || options === void 0 ? void 0 : options.comparing) {
                    let match = false;
                    for (const compareField of options.comparing) {
                        match = (0, compare_1.eq)(prev.get()[compareField], i.get()[compareField]);
                        if (!match) {
                            break;
                        }
                    }
                    if (match) {
                        target.deleteIndex(index);
                    }
                }
                else if ((0, compare_1.eq)(prev, i) === true) {
                    target.deleteIndex(index);
                }
            }
            else if ((options === null || options === void 0 ? void 0 : options.index) && options.index.get() === index) {
                target.deleteIndex(options.index.get() - 1);
            }
            else if ((options === null || options === void 0 ? void 0 : options.fromValue) && (0, compare_1.eq)(options.fromValue, i)) {
                target.deleteIndex(index);
            }
            else if ((options === null || options === void 0 ? void 0 : options.from) && options.from.get() <= index + 1) {
                target.deleteIndex(index);
            }
            else if ((options === null || options === void 0 ? void 0 : options.to) && options.to.get() <= index + 1) {
                target.deleteIndex(0);
            }
            prev = i;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.deleteInternal = deleteInternal;
//# sourceMappingURL=delete_internal.js.map