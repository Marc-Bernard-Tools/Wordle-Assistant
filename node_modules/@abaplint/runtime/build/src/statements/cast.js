"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cast = void 0;
const compare_1 = require("../compare");
function throwError() {
    // @ts-ignore
    if (abap.Classes["CX_SY_MOVE_CAST_ERROR"] !== undefined) {
        // @ts-ignore
        throw new abap.Classes["CX_SY_MOVE_CAST_ERROR"]();
    }
    else {
        throw "Global class CX_SY_MOVE_CAST_ERROR not found";
    }
}
// todo, field symbols as input?
// todo, local classes?
// check with javascript instanceof?
// handling interfaces?
async function cast(target, source) {
    var _a;
    if ((0, compare_1.initial)(source)) {
        target.clear();
        return;
    }
    // eslint-disable-next-line prefer-const
    let checkIntf = true;
    const targetName = (_a = target.getQualifiedName()) === null || _a === void 0 ? void 0 : _a.toUpperCase();
    // @ts-ignore
    const targetClass = abap.Classes[targetName];
    /*
    if (targetName?.startsWith("IF_") === false
        && targetName?.startsWith("ZIF_") === false) { // todo, interfaces are also classes but not inherited
*/
    if ((targetClass === null || targetClass === void 0 ? void 0 : targetClass.INTERNAL_TYPE) === "CLAS") {
        // using "instanceof" is probably wrong in some cases,
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof
        if (source.get() instanceof targetClass === false) {
            throwError();
        }
    }
    else if (checkIntf === true && (targetClass === null || targetClass === void 0 ? void 0 : targetClass.INTERNAL_TYPE) === "INTF") {
        const list = [...source.get().constructor.IMPLEMENTED_INTERFACES];
        // interfaces implemented in super classes
        let sup = source.get().super;
        while (sup !== undefined) {
            list.push(...sup.get().constructor.IMPLEMENTED_INTERFACES);
            sup = sup.get().super;
        }
        // interfaces implemented by interfaces
        const visit = new Set(list);
        while (visit.size > 0) {
            const intfName = visit.values().next().value;
            // @ts-ignore
            const intf = abap.Classes[intfName];
            for (const i of (intf === null || intf === void 0 ? void 0 : intf.IMPLEMENTED_INTERFACES) || []) {
                if (visit.has(i) === false) {
                    visit.add(i);
                    list.push(i);
                }
            }
            visit.delete(intfName);
        }
        const isImplemented = list.some(i => i === targetName);
        if (isImplemented === false) {
            throwError();
        }
    }
    target.set(source);
}
exports.cast = cast;
//# sourceMappingURL=cast.js.map