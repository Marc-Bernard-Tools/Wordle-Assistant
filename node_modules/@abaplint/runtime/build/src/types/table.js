"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = exports.LoopIndex = exports.TableAccessType = void 0;
const integer_1 = require("./integer");
const string_1 = require("./string");
const clone_1 = require("../clone");
const field_symbol_1 = require("./field_symbol");
const data_reference_1 = require("./data_reference");
const insert_internal_1 = require("../statements/insert_internal");
var TableAccessType;
(function (TableAccessType) {
    TableAccessType["standard"] = "STANDARD";
    TableAccessType["sorted"] = "SORTED";
    TableAccessType["hashed"] = "HASHED";
    TableAccessType["index"] = "INDEX";
    TableAccessType["any"] = "ANY";
})(TableAccessType = exports.TableAccessType || (exports.TableAccessType = {}));
class LoopIndex {
    constructor(start) {
        this.index = start;
    }
}
exports.LoopIndex = LoopIndex;
class Table {
    constructor(rowType, options, qualifiedName) {
        this.value = [];
        this.loops = new Set();
        this.rowType = rowType;
        this.options = options;
        if (this.options === undefined) {
            this.options = {
                type: TableAccessType.standard,
                keyFields: [],
                isUnique: false,
                withHeader: false,
            };
        }
        this.qualifiedName = qualifiedName === null || qualifiedName === void 0 ? void 0 : qualifiedName.toUpperCase();
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    getOptions() {
        return this.options;
    }
    startLoop(start = 0) {
        const l = new LoopIndex(start);
        this.loops.add(l);
        return l;
    }
    unregisterLoop(loop) {
        this.loops.delete(loop);
    }
    getRowType() {
        return this.rowType;
    }
    // Modifications to the array must be done inside this class, in order to keep track of LOOP indexes
    array() {
        return this.value;
    }
    clear() {
        this.value = [];
    }
    set(tab) {
        this.clear();
        for (const a of tab.array()) {
            // this clones the values, and add sorting if required
            (0, insert_internal_1.insertInternal)({ table: this, data: a });
        }
    }
    insertIndex(item, index) {
        const val = this.getValue(item);
        this.value.splice(index, 0, val);
        for (const l of this.loops.values()) {
            if (l.index <= index) {
                l.index++;
            }
        }
        return val;
    }
    deleteIndex(index) {
        if (index > this.value.length) {
            return;
        }
        if (index === this.value.length - 1) {
            this.value.pop(); // pop'ing is faster than splice
        }
        else if (index === 0) {
            this.value.shift();
        }
        else {
            this.value.splice(index, 1);
        }
        for (const l of this.loops.values()) {
            if (l.index >= index) {
                l.index--;
            }
        }
    }
    append(item, cloneRow = true) {
        if (item instanceof field_symbol_1.FieldSymbol) {
            const p = item.getPointer();
            if (p === undefined) {
                throw new Error("APPEND, fs not assigned");
            }
            this.value.push(p);
            return item;
        }
        else if (item instanceof data_reference_1.DataReference) {
            const ref = new data_reference_1.DataReference(item.getType());
            ref.assign(item.getPointer());
            this.value.push(ref);
            return ref;
        }
        else {
            const val = this.getValue(item, cloneRow);
            const p = (0, clone_1.clone)(this.rowType);
            p.set(val);
            this.value.push(p);
            return p;
        }
    }
    appendInitial() {
        // note that this will clone the object
        this.append(this.rowType);
        // @ts-ignore
        abap.builtin.sy.get().tabix.set(this.value.length);
        return this.value[this.value.length - 1];
    }
    sort(compareFn) {
        this.value.sort(compareFn);
    }
    ///////////////////////////
    getValue(item, cloneRow = true) {
        // make sure to do conversion if needed
        if (typeof item === "number") {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(new integer_1.Integer().set(item));
            return tmp;
        }
        else if (typeof item === "string") {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(new string_1.String().set(item));
            return tmp;
        }
        else if (cloneRow === true) {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(item);
            return tmp;
        }
        else {
            return item;
        }
    }
}
exports.Table = Table;
//# sourceMappingURL=table.js.map